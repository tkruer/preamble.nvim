---@class PreambleRenderResult
---@field lines string[]
---@field cursor integer[]|nil
---@field template_path string

local config = require("preamble.config")

local M = {}

---@param value any
---@return boolean
local function is_empty(value)
  return value == nil or value == ""
end

---@param bufnr integer
---@return boolean
local function is_buffer_empty(bufnr)
  local ok_count, line_count = pcall(vim.api.nvim_buf_line_count, bufnr)
  if not ok_count then
    return false
  end

  if line_count == 0 then
    return true
  end

  local ok_lines, lines = pcall(vim.api.nvim_buf_get_lines, bufnr, 0, math.min(line_count, 1), false)
  if not ok_lines then
    return false
  end

  if line_count == 1 and (lines[1] == nil or lines[1] == "") then
    return true
  end

  return false
end

---@return string
local function resolve_author()
  return config.opts.author
    or vim.g.header_author
    or vim.env.GIT_AUTHOR_NAME
    or vim.env.USER
    or "Unknown"
end

---@return string
local function resolve_email()
  return config.opts.email
    or vim.g.header_email
    or vim.env.GIT_AUTHOR_EMAIL
    or vim.env.EMAIL
    or ""
end

---@param ft string
---@return string
local function template_path_for_filetype(ft)
  return config.opts.templates_dir .. ft .. ".template"
end

---@param path string
---@return boolean
local function template_exists(path)
  local ok_stat, stat = pcall(vim.uv.fs_stat, path)
  return ok_stat and stat and stat.type == "file"
end

---@param path string
---@return string[]|nil
local function read_template(path)
  local ok_read, lines = pcall(vim.fn.readfile, path)
  if not ok_read then
    return nil
  end

  return lines
end

---@param bufnr integer
---@return boolean
local function has_header_marker(bufnr)
  local scan_count = config.opts.header_scan_lines or config.defaults.header_scan_lines
  local line_count = vim.api.nvim_buf_line_count(bufnr)
  local end_line = math.min(scan_count, line_count)
  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, end_line, false)

  for _, line in ipairs(lines) do
    if line:match("[Ff]ile:") or line:match("Generated by Preamble") then
      return true
    end
  end

  return false
end

---@param lines string[]
---@param bufnr integer
---@return string[], integer[]
local function render_lines(lines, bufnr)
  local now = os.date("*t")
  local replacements = {
    ["<FILE>"] = vim.fn.expand("%:t"),
    ["<PATH>"] = vim.fn.expand("%"),
    ["<DATE>"] = os.date("%Y-%m-%d"),
    ["<DATETIME>"] = os.date("%Y-%m-%d %H:%M"),
    ["<YEAR>"] = string.format("%04d", now.year),
    ["<AUTHOR>"] = resolve_author(),
    ["<EMAIL>"] = resolve_email(),
  }

  local rendered = {}
  local cursor = nil

  for idx, line in ipairs(lines) do
    local processed = line

    local cursor_col = processed:find("<CURSOR>", 1, true)
    if cursor_col and not cursor then
      cursor = { idx, cursor_col - 1 }
    end

    processed = processed:gsub("<CURSOR>", "")

    for placeholder, value in pairs(replacements) do
      processed = processed:gsub(placeholder, value)
    end

    rendered[idx] = processed
  end

  if cursor then
    return rendered, cursor
  end

  local comment_prefix = nil
  local ok_comment, commentstring = pcall(vim.api.nvim_buf_get_option, bufnr, "commentstring")
  if ok_comment and commentstring and commentstring ~= "" then
    comment_prefix = commentstring:gsub("%%s", "")
    comment_prefix = vim.trim(comment_prefix)
    if comment_prefix == "" then
      comment_prefix = nil
    end
  end

  for idx, line in ipairs(rendered) do
    local trimmed = vim.trim(line)
    if trimmed ~= "" then
      if not comment_prefix or not vim.startswith(trimmed, comment_prefix) then
        return rendered, { idx, 0 }
      end
    end
  end

  return rendered, { 1, 0 }
end

---@return PreambleRenderResult|nil
function M.render()
  local ft = vim.bo.filetype
  if is_empty(ft) or not config.allowed_filetype(ft) then
    return nil
  end

  local path = template_path_for_filetype(ft)
  if not template_exists(path) then
    return nil
  end

  local lines = read_template(path)
  if not lines then
    return nil
  end

  local rendered, cursor = render_lines(lines, vim.api.nvim_get_current_buf())
  return {
    lines = rendered,
    cursor = cursor,
    template_path = path,
  }
end

---@param opts? { force?: boolean }
---@return boolean
function M.insert(opts)
  opts = opts or {}
  local bufnr = vim.api.nvim_get_current_buf()

  if not opts.force and (not config.opts.enabled or not is_buffer_empty(bufnr)) then
    return false
  end

  if has_header_marker(bufnr) then
    return false
  end

  local rendered = M.render()
  if not rendered or not rendered.lines then
    return false
  end

  local ok_set = pcall(vim.api.nvim_buf_set_lines, bufnr, 0, -1, false, rendered.lines)
  if not ok_set then
    return false
  end

  if rendered.cursor then
    pcall(vim.api.nvim_win_set_cursor, 0, rendered.cursor)
  end

  return true
end

return M
