local M = {}

local defaults = {
  templates_dir = vim.fn.stdpath("config") .. "/templates/",
  author = nil,
  email = nil,
  enabled = true,
  filetypes = {
    allowlist = nil,
    denylist = nil,
  },
  header_scan_lines = 20,
}

M._opts = vim.deepcopy(defaults)

local function is_empty(value)
  return value == nil or value == ""
end

local function normalize_templates_dir(path)
  if is_empty(path) then
    return defaults.templates_dir
  end

  if path:sub(-1) ~= "/" then
    return path .. "/"
  end

  return path
end

local function merge_opts(opts)
  local merged = vim.tbl_deep_extend("force", vim.deepcopy(defaults), opts or {})
  merged.templates_dir = normalize_templates_dir(merged.templates_dir)
  return merged
end

local function notify(msg, level)
  pcall(vim.notify, msg, level or vim.log.levels.INFO, { title = "preamble" })
end

local function is_buffer_empty(bufnr)
  local ok_count, line_count = pcall(vim.api.nvim_buf_line_count, bufnr)
  if not ok_count then
    return false
  end

  if line_count == 0 then
    return true
  end

  local ok_lines, lines = pcall(vim.api.nvim_buf_get_lines, bufnr, 0, math.min(line_count, 1), false)
  if not ok_lines then
    return false
  end

  if line_count == 1 and (lines[1] == nil or lines[1] == "") then
    return true
  end

  return false
end

local function allowed_filetype(ft)
  local allowlist = M._opts.filetypes.allowlist
  local denylist = M._opts.filetypes.denylist

  if type(allowlist) == "table" and #allowlist > 0 then
    local allowed = false
    for _, entry in ipairs(allowlist) do
      if entry == ft then
        allowed = true
        break
      end
    end

    if not allowed then
      return false
    end
  end

  if type(denylist) == "table" and #denylist > 0 then
    for _, entry in ipairs(denylist) do
      if entry == ft then
        return false
      end
    end
  end

  return true
end

local function resolve_author()
  return M._opts.author
    or vim.g.header_author
    or vim.env.GIT_AUTHOR_NAME
    or vim.env.USER
    or "Unknown"
end

local function resolve_email()
  return M._opts.email
    or vim.g.header_email
    or vim.env.GIT_AUTHOR_EMAIL
    or vim.env.EMAIL
    or ""
end

local function template_path_for_filetype(ft)
  return M._opts.templates_dir .. ft .. ".template"
end

local function template_exists(path)
  local ok_stat, stat = pcall(vim.uv.fs_stat, path)
  return ok_stat and stat and stat.type == "file"
end

local function read_template(path)
  local ok_read, lines = pcall(vim.fn.readfile, path)
  if not ok_read then
    return nil
  end

  return lines
end

local function has_header_marker(bufnr)
  local scan_count = M._opts.header_scan_lines or defaults.header_scan_lines
  local line_count = vim.api.nvim_buf_line_count(bufnr)
  local end_line = math.min(scan_count, line_count)
  local lines = vim.api.nvim_buf_get_lines(bufnr, 0, end_line, false)

  for _, line in ipairs(lines) do
    if line:match("[Ff]ile:") or line:match("Generated by Preamble") then
      return true
    end
  end

  return false
end

local function render_lines(lines, bufnr)
  local now = os.date("*t")
  local replacements = {
    ["<FILE>"] = vim.fn.expand("%:t"),
    ["<PATH>"] = vim.fn.expand("%"),
    ["<DATE>"] = os.date("%Y-%m-%d"),
    ["<DATETIME>"] = os.date("%Y-%m-%d %H:%M"),
    ["<YEAR>"] = string.format("%04d", now.year),
    ["<AUTHOR>"] = resolve_author(),
    ["<EMAIL>"] = resolve_email(),
  }

  local rendered = {}
  local cursor = nil

  for idx, line in ipairs(lines) do
    local processed = line

    local cursor_col = processed:find("<CURSOR>", 1, true)
    if cursor_col and not cursor then
      cursor = { idx, cursor_col - 1 }
    end

    processed = processed:gsub("<CURSOR>", "")

    for placeholder, value in pairs(replacements) do
      processed = processed:gsub(placeholder, value)
    end

    rendered[idx] = processed
  end

  if cursor then
    return rendered, cursor
  end

  local comment_prefix = nil
  local ok_comment, commentstring = pcall(vim.api.nvim_buf_get_option, bufnr, "commentstring")
  if ok_comment and commentstring and commentstring ~= "" then
    comment_prefix = commentstring:gsub("%%s", "")
    comment_prefix = vim.trim(comment_prefix)
    if comment_prefix == "" then
      comment_prefix = nil
    end
  end

  for idx, line in ipairs(rendered) do
    local trimmed = vim.trim(line)
    if trimmed ~= "" then
      if not comment_prefix or not vim.startswith(trimmed, comment_prefix) then
        return rendered, { idx, 0 }
      end
    end
  end

  return rendered, { 1, 0 }
end

function M.render()
  local ft = vim.bo.filetype
  if is_empty(ft) or not allowed_filetype(ft) then
    return nil
  end

  local path = template_path_for_filetype(ft)
  if not template_exists(path) then
    return nil
  end

  local lines = read_template(path)
  if not lines then
    return nil
  end

  local rendered, cursor = render_lines(lines, vim.api.nvim_get_current_buf())
  return {
    lines = rendered,
    cursor = cursor,
    template_path = path,
  }
end

function M.insert(opts)
  opts = opts or {}
  local bufnr = vim.api.nvim_get_current_buf()

  if not opts.force and (not M._opts.enabled or not is_buffer_empty(bufnr)) then
    return false
  end

  if has_header_marker(bufnr) then
    return false
  end

  local rendered = M.render()
  if not rendered or not rendered.lines then
    return false
  end

  local ok_set = pcall(vim.api.nvim_buf_set_lines, bufnr, 0, -1, false, rendered.lines)
  if not ok_set then
    return false
  end

  if rendered.cursor then
    pcall(vim.api.nvim_win_set_cursor, 0, rendered.cursor)
  end

  return true
end

local function setup_commands()
  pcall(vim.api.nvim_del_user_command, "PreambleInsert")
  pcall(vim.api.nvim_del_user_command, "PreamblePreview")

  vim.api.nvim_create_user_command("PreambleInsert", function(command_opts)
    local inserted = M.insert({ force = command_opts.bang })
    if not inserted then
      notify("Preamble not inserted", vim.log.levels.DEBUG)
    end
  end, { bang = true, desc = "Insert file preamble" })

  vim.api.nvim_create_user_command("PreamblePreview", function()
    local rendered = M.render()
    if not rendered then
      notify("No preamble template available for this filetype", vim.log.levels.WARN)
      return
    end

    vim.cmd("new")
    local preview_buf = vim.api.nvim_get_current_buf()
    vim.bo[preview_buf].buftype = "nofile"
    vim.bo[preview_buf].bufhidden = "wipe"
    vim.bo[preview_buf].swapfile = false
    vim.bo[preview_buf].modifiable = true
    vim.api.nvim_buf_set_lines(preview_buf, 0, -1, false, rendered.lines)
    vim.bo[preview_buf].modifiable = false
    vim.bo[preview_buf].filetype = "headerpreview"
  end, { desc = "Preview rendered file preamble" })
end

local function setup_autocmd()
  local group = vim.api.nvim_create_augroup("Preamble", { clear = true })

  vim.api.nvim_create_autocmd("BufNewFile", {
    group = group,
    callback = function()
      M.insert({ force = false })
    end,
  })
end

function M.setup(opts)
  M._opts = merge_opts(opts)
  setup_autocmd()
  setup_commands()
end

return M
